---
slug: password-storage
title: 密码存储备忘录
authors: krossdev
tags: [password storage, cheat sheet]
---

:::note 注意
这是一篇译文，仅供参考，原文地址：
https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
:::

## 介绍

即使应用程序或数据库遭泄漏也要防止攻击者获取密码，这是基本需求。
大多数现代语言和框架都提供内置功能来帮助安全存储密码。

<!-- truncate -->

在攻击者获得存储的密码哈希后，他们总是能够离线暴力破解哈希。作为防御者，
只能通过选择尽可能占用资源的哈希算法来减缓离线攻击。

此备忘录提供了与存储密码相关的各个方面考量的指南。简而言之：

- **使用最低配置为 15 MiB 内存、迭代次数为 2 和并行度为 1 的 [Argon2id](#argon2id)**
- **如果 Argon2id 不可用，请使用工作系数为 10 或更多且密码限制为 72 字节的 [bcrypt](#bcrypt)**
- **对于使用 [scrypt](#scrypt) 的旧系统，使用最小 CPU/内存成本参数 (2^16)、最小块大小 8（1024 字节）和并行化参数 1**
- **如果需要符合 FIPS-140，请使用工作因子为 310,000 或更高的 [PBKDF2](#pbkdf2)，**
  **并使用 HMAC-SHA-256 作为内部哈希函数**
- **考虑使用[pepper](#胡椒粉peppering) 来提供额外的纵深防御（尽管单独使用，它不会提供额外的安全特性）**

## 背景

### 哈希 VS 加密

哈希和加密都提供了保护敏感数据安全的方法。但是，在几乎所有情况下，密码都应该哈希而不是加密。

**哈希是单向函数**（即不可能“解密”哈希值来获得原始明文值）。哈希适用于密码验证。
即使攻击者获得了经过哈希的密码，他们也无法将其输入应用程序的密码字段并以受害者身份登录。

**加密是双向函数**，意味着可以还原原始明文。加密适用于存储诸如用户地址之类的数据，
因为该数据以明文形式显示在用户的个人资料中。哈希他们的地址会导致乱码。

在密码存储的环境中，仅在需要获取原始明文密码的极端情况下才使用加密。
如果应用程序需要使用明文密码向另一个不支持以程序授予访问权限的现代方式（例如 OpenID Connect (OIDC)）
的系统进行身份验证时，这可能是必要的。在可能的情况下，应使用替代方案以避免需要以加密形式存储密码。

有关加密的进一步指导，请参阅[加密存储备忘单]。

### 攻击者如何破解密码哈希

虽然无法“解密”哈希以获得原始密码，但在某些情况下可以“破解”哈希。

基本步骤是：

- 选择一个你认为受害者选择的密码（例如password1!）
- 计算哈希
- 将计算的哈希值与受害者的哈希值进行比较。如果它们匹配，您就正确地“破解”了哈希，现在知道了他们密码的明文值。

对大量潜在的候选密码重复此过程。可以使用不同的方法来选择候选密码，包括：

- 从其他受感染站点获得的密码列表
- 蛮力（尝试所有可能的候选）
- 常用密码字典或词表

虽然排列组合的数量很大，但使用高速硬件（例如 GPU）和云服务以及租用许多服务器，
攻击者成功破解密码的成本相对较小，尤其是在哈希未遵循最佳实践的情况下。

**使用现代哈希算法存储并使用哈希最佳实践的强密码应该是攻击者无法破解的**。
作为应用程序所有者，你有责任选择现代哈希算法。

## 密码强度概念

### 盐

盐是唯一的、随机生成的字符串，作为密码的一部分加入到哈希处理过程中。
由于每个用户的盐是唯一的，攻击者必须使用相应的盐一次破解一个哈希，
而不是计算一次哈希并将其与每个存储的哈希进行比较。
这使得破解大量哈希变得更加困难，因为所需的时间与哈希数量成正比。

盐还可以防止攻击者使用彩虹表或基于数据库的查找预先计算哈希值。最后，
加盐意味着在不破解哈希值的情况下无法确定两个用户是否具有相同的密码，因为即使密码相同，
不同的盐值也会导致不同的哈希值。

现代哈希算法（例如 Argon2id、bcrypt 和 PBKDF2）会自动对密码加盐，因此在使用它们时不需要额外的步骤。

### 胡椒粉(Peppering)

胡椒粉可以和盐一起使用，以提供一个附加的保护层。胡椒粉的目的是防止攻击者在只能访问数据库的情况下破解任何哈希，
例如，如果他们利用了 SQL 注入漏洞或获得了数据库的备份。

策略之一是像通常一样对密码进行哈希处理（使用密码哈希算法），
然后在将密码哈希存储在数据库中之前使用对称加密密钥对哈希进行 HMAC 或加密，密钥充当胡椒粉。
胡椒粉策略不会以任何方式影响密码哈希函数。

- 胡椒粉在存储的密码之间共享，而不是像盐一样独一无二。
- 与盐不同，胡椒粉不应该存储在数据库中。
- 胡椒粉是秘密，应该存储在“秘密保险库”或 HSM（硬件安全模块）中。
- 像任何其他加密密钥一样，应该考虑轮换策略。

### 工作因子

工作因子本质上是为每个密码执行的哈希算法的迭代次数（通常，它实际上是2^work迭代）。
工作因子的目的是使计算哈希的计算成本更高，这反过来会降低速度和/或增加攻击者尝试破解密码的成本。
工作因子通常存储在哈希输出中。

在选择工作因子时，需要在安全性和性能之间取得平衡。更高的工作系数将使攻击者更难破解哈希值，
但也会使验证登录尝试的过程变慢。如果工作系数太高，这可能会降低应用程序的性能，
并且还可能被攻击者用来通过大量登录尝试耗尽服务器的 CPU 来执行拒绝服务攻击。

理想的工作因子没有黄金法则——它取决于服务器的性能和应用程序上的用户数量。
确定最佳工作系数需要在应用程序使用的特定服务器上进行实验。作为一般规则，计算哈希应该不到一秒钟。

### 提升工作因子

拥有工作因子的一个关键优势是，随着硬件变得更强大和更便宜，它可以随着时间的推移而增加。

升级工作因子的最常见方法是等到用户下一次进行身份验证，然后使用新的工作因子重新哈希他们的密码。
这意味着不同的哈希将具有不同的工作因子，如果用户不重新登录应用程序，可能会导致哈希永远不会升级。
根据应用程序，删除旧的密码哈希值并要求用户在下次需要登录时重置密码以避免存储旧的和不太安全的哈希值可能是合适的。

## 密码哈希算法

有许多现代哈希算法专为安全存储密码而设计。这意味着它们应该很慢（不像 MD5 和 SHA-1 之类的算法设计得很快），
并且可以通过更改工作因子来配置它们的速度。

网站不用隐藏他们使用的密码哈希算法。如果您使用具有适当配置参数的现代密码哈希算法，
那么公开说明正在使用的密码哈希算法并在[此处](https://pulse.michalspacek.cz/passwords/storages)
列出应该是安全的。

下面列出了应该考虑的主要三种算法：

### Argon2id

[Argon2]是 2015 年[密码哈希竞赛]的获胜者。该算法有三个不同的版本，应该使用 Argon2id 变体，
因为它提供了一种平衡的方法来抵抗侧信道和基于 GPU 的攻击。

Argon2id 不像其他算法那样是一个简单的工作因子，它具有三个可以配置的不同参数。
Argon2id 应使用以下配置设置之一作为基本最小值，其中包括最小内存大小 (m)、最小迭代次数 (t) 和并行度 (p)。

- m=37 MiB，t=1，p=1
- m=15 MiB，t=2，p=1

这两个配置设置在它们提供的防御方面是等效的。唯一的区别是 CPU 和 RAM 使用之间的权衡。

### Scrypt

[scrypt]是[Colin Percival]创建的基于密码的密钥派生函数。虽然新系统应考虑使用Argon2id进行密码哈希，
但在旧系统中使用时应正确配置 scrypt。

与Argon2id一样， scrypt 具有三个可以配置的不同参数。scrypt 应使用以下配置设置之一作为基本最小值，
其中包括最小 CPU/内存成本参数 (N)、块大小 (r) 和并行度 (p)。

- N=2^16（64 MiB），r=8（1024 字节），p=1
- N=2^15（32 MiB），r=8（1024 字节），p=2
- N=2^14（16 MiB），r=8（1024 字节），p=4
- N=2^13（8 MiB），r=8（1024 字节），p=8
- N=2^12（4 MiB），r=8（1024 字节），p=15

这些配置设置在它们提供的防御方面是等效的。唯一的区别是 CPU 和 RAM 使用之间的权衡。

### Bcrypt

如果 Argon2id 不可用或需要 PBKDF2 来实现 FIPS-140 合规性，则 [bcrypt] 密码哈希函数应该是密码存储的第二选择。

bcrypt 的最小工作系数应该是 10。

#### 输入限制

[对于大多数实现]， bcrypt 的最大输入长度为 72 字节。为防止出现此问题，在使用 bcrypt
时应强制执行最大密码长度为 72 字节（如果使用的实现具有较小的限制，则应更少）。

#### 预哈希密码

另一种方法是使用快速算法（例如 SHA-256）对用户提供的密码进行预哈希，然后使用 bcrypt
（即 `bcrypt(base64(hmac-sha256(data:$password, key:$pepper)), $salt, $cost)`）
对生成的哈希进行哈希。这是一种危险的（但常见的）做法，在[将 bcrypt 与其他哈希函数结合使用]时，
由于[密码脱壳]和其他问题，**应该避免**这种做法。

### PBKDF2

[PBKDF2]由[NIST]推荐并具有 FIPS-140 验证的实现。因此，当需要这些时，它应该是首选算法。

PBKDF2 要求您选择内部哈希算法，例如 HMAC 或各种其他哈希算法。HMAC-SHA-256 得到广泛支持，并被 NIST 推荐。

PBKDF2 的工作因子是通过迭代计数实现的，应该根据使用的内部哈希算法进行不同的设置。

- PBKDF2-HMAC-SHA1：720,000 次迭代
- PBKDF2-HMAC-SHA256：310,000 次迭代
- PBKDF2-HMAC-SHA512：120,000 次迭代

这些配置设置在它们提供的防御方面是等效的。

当 PBKDF2 与 HMAC 一起使用，并且密码长于哈希函数的块大小（SHA-256 为 64 字节）时，
密码将自动预哈希。例如，密码
“`This is a password longer than 512 bits which is the block size of SHA-256`”
被转换为哈希值（十六进制）`fa91498c139805af73f7ba275cca071e78d78675027000c99a9925e2ec92e`
一个好的 PBKDF2 实现将在昂贵的迭代哈希阶段之前执行此步骤，但某些实现在每次迭代时执行转换。
这会使哈希长密码比哈希短密码要贵得多。如果用户可以提供很长的密码，则存在潜在的拒绝服务漏洞，
例如2013 年在Django中发布的那个。 手动预哈希可以降低这种风险，但需要在预哈希步骤中加盐。

## 升级旧哈希

对于使用安全性较低的哈希算法（例如 MD5 或 SHA-1）构建的较旧应用程序，
这些哈希应升级为如上所述的现代密码哈希算法。当用户下次输入他们的密码时
（通常通过在应用程序上进行身份验证），应该使用新算法对其进行重新哈希。
使用户的当前密码过期并要求他们输入一个新密码也是一种很好的做法，这样任何旧的（不太安全的）哈希对攻击者都不再有用。

但是，这种方法意味着旧的（安全性较低的）哈希将存储在数据库中，直到用户登录为止。可以采取两种主要方法来避免这种困境。

一种方法是过期并删除长时间不活动的用户的密码哈希，并要求他们重置密码以再次登录。虽然安全，
但这种方法不是特别友好。许多用户的密码过期可能会给支持人员带来问题，或者可能被用户解释为违规的迹象。

另一种方法是使用现有的密码哈希作为更安全算法的输入。例如，如果应用程序最初将密码存储为 `md5($password)`，
则可以轻松升级到 `bcrypt(md5($password))`. 分层哈希避免了知道原始密码的需要；
但是，它可以使哈希更容易破解。下次用户登录时，应将这些哈希值替换为用户密码的直接哈希值。

假设无论选择哪种密码哈希方法，将来都必须升级。确保升级哈希算法尽可能简单。在过渡期间，
允许混合使用新旧哈希算法。如果使用标准格式（例如[模块化 PHC 字符串格式]）将密码哈希算法和工作因子与密码一起存储，
则使用混合哈希算法会更容易。

### 国际化字符

确保你的哈希库能够接受各种字符并与所有 Unicode 代码点兼容。用户应该能够使用现代设备
（尤其是移动键盘）上可用的所有字符。他们应该能够从各种语言中选择密码并包括象形图。
在哈希之前，不应减少用户条目的熵。密码哈希库需要能够使用可能包含 NULL 字节的输入。


[加密存储备忘单]: https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html
[Argon2]: https://en.wikipedia.org/wiki/Argon2
[密码哈希竞赛]: https://password-hashing.net/
[scrypt]: https://www.tarsnap.com/scrypt/scrypt.pdf
[Colin Percival]: https://twitter.com/cperciva
[bcrypt]: https://en.wikipedia.org/wiki/bcrypt
[对于大多数实现]: https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length
[将 bcrypt 与其他哈希函数结合使用]: https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html
[密码脱壳]: https://www.youtube.com/watch?v=OQD3qDYMyYQ
[PBKDF2]: https://en.wikipedia.org/wiki/PBKDF2
[NIST]: https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver
[模块化 PHC 字符串格式]: https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md
