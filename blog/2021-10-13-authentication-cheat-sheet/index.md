---
slug: authentication
title: 身份验证备忘录
authors: krossdev
tags: [authentication, cheat sheet]
---

:::note 注意
这是一篇译文，仅供参考，原文地址：
https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html
:::

## 介绍

**身份验证**是验证个人、实体或网站真实身份的过程。
Web 应用环境中的身份验证通常通过提交用户名或 ID 以及只有给定用户应该知道的一项或多项私人信息来执行。

**会话管理**是服务器维护与其交互实体的状态的过程。服务器在后续整个事务中对请求做出反应必需记住会话状态。
会话通过会话标识符在服务器上维护，该标识符可以在发送和接收请求时在客户端和服务器之间来回传递。
每个用户的会话应该是唯一的，并且很难通过计算来预测。
[会话管理备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
包含有关该领域最佳实践的进一步指导。

<!-- truncate -->

 ## 身份验证通用指南

### 用户 ID

确保您的用户名/用户 ID 不区分大小写。用户 'smith' 和用户 'Smith' 应该是同一个用户。
用户名也应该是唯一的。对于高度安全的应用程序，可以分配用户名并保密，而不是用户定义的公共数据。

#### 电子邮件地址作为用户 ID

有关验证电子邮件地址的信息，请访问[输入验证备忘录电子邮件讨论](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html#Email_Address_Validation)。

### 身份验证解决方案和敏感账户

- **不允许**使用敏感帐户（即可以在解决方案内部使用的帐户，例如后端/中间件/数据库）登录到任何前端用户界面
- **不要**使用内部用于不安全访问（例如公共访问/DMZ）的相同身份验证解决方案（例如 IDP/AD）

### 实施适当的密码强度控制

使用密码进行身份验证时的一个关键问题是密码强度。
“强”密码策略使得通过手动或自动方式猜测密码变得困难甚至不可能。以下特征定义了强密码：

- 密码长度
  - 密码的最小长度应由应用程序强制执行。少于 8 个字符的密码被认为是弱密码 (
    [NIST SP800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html))。
  - 最大密码长度不应设置得太低，因为它会阻止用户创建密码短语。
    由于某些哈希算法的限制，常见的最大长度为 64 个字符，如[密码存储备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#maximum-password-lengths)中所述。
    设置最大密码长度以防止[长密码拒绝服务攻击](https://www.acunetix.com/vulnerabilities/web/long-password-denial-of-service/)很重要。
- 不要默默地截断密码。[密码存储备忘录]提供了有关如何处理超过最大长度的密码的进一步指导。
- 允许使用**所有**字符，包括 unicode 和空格。不应该有限制允许字符类型的密码组合规则。
- 确保在密码泄露时或在身份泄露时进行凭证轮换。
- 包括密码强度测量尺，以帮助用户创建更复杂的密码并阻止常见的和以前泄露的密码
  - [zxcvbn](https://github.com/dropbox/zxcvbn) 库可用于此目的。（注意这个库不再维护）
  - [Pwned Passwords](https://haveibeenpwned.com/Passwords) 是一项服务，
    可以根据以前泄露的密码检查密码。您可以自己托管或使用
    [API](https://haveibeenpwned.com/API/v3#PwnedPasswords)。

#### 有关更多详细信息，请检查

- [ASVS v4.0 密码安全要求](https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md#v21-password-security-requirements)
- [密码进化：现代身份验证指南](https://www.troyhunt.com/passwords-evolved-authentication-guidance-for-the-modern-era/)

### 实施安全密码恢复机制

应用程序通常具有一种机制，可以为用户提供一种在忘记密码时访问其帐户的方法。
有关此功能的详细信息，请参阅[忘记密码备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)。

### 以安全的方式存储密码

应用程序使用正确的加密技术存储密码至关重要。
有关此功能的详细信息，请参阅[密码存储备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)。

### 使用安全函数比较密码哈希

在可能的情况下，应使用语言或框架提供的安全密码比较功能将用户提供的密码与存储的密码哈希进行比较，
比如 PHP 中的 `password_verify()` 函数。如果这是不可能的，请确保比较函数：

- 具有最大输入长度，以防止输入很长的拒绝服务攻击。
- 显式设置两个变量的类型，以防止类型混淆攻击，例如 PHP 中的
  [Magic Hashes](https://www.whitehatsec.com/blog/magic-hashes/)。
- 以恒定时间返回，以防止定时攻击。

### 更改密码功能

在开发更改密码功能时，请确保具备：

- 用户已通过活动的会话进行了身份验证。
- 当前密码验证。这是为了确保更改密码的是合法用户。滥用情况是这样的：
  合法用户使用公共计算机登录，忘记注销，然后另一个用户使用这台公共计算机。如果我们不验证当前密码，
  另一个用户可以更改密码。

### 仅通过 TLS 或其他强传输传输密码

请参阅：[传输层保护备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)

登录页面和所有后续经过身份验证的页面必须通过 TLS 或其他强传输访问。
登录登录页面未使用 TLS 或其他强传输允许攻击者修改登录表单 Action，导致用户的凭据被发布到任意位置。
登录后未能对经过身份验证的页面使用 TLS 或其他强传输使攻击者能够查看未加密的会话 ID
并危及用户经过身份验证的会话。

### 敏感功能需要重新认证

为了减轻 CSRF 和会话劫持，在更新敏感的帐户信息（例如用户的密码、用户的电子邮件）或敏感交易之前，
要求提供帐户的当前凭据非常重要，例如将购买的商品运送到新地址。
如果没有这种对策，攻击者可能能够通过 CSRF 或 XSS 攻击执行敏感交易，而无需知道用户当前的凭据。
此外，攻击者可能会临时物理访问用户的浏览器或窃取他们的会话 ID 以接管用户的会话。

### 考虑强交易认证

一些应用程序应该使用第二个因素来检查用户是否可能执行敏感操作。有关更多信息，请参阅
[交易授权备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Transaction_Authorization_Cheat_Sheet.html)。

#### TLS 客户端认证

TLS 客户端身份验证，也称为双向 TLS 身份验证，由浏览器和服务器组成，在 TLS 握手过程中发送各自的
TLS 证书。
就像您可以通过使用证书并询问知名证书颁发机构 (CA) 证书是否有效来验证服务器的真实性一样，
服务器也可以通过从客户端接收证书并针对第三方 CA 或它自己的 CA 进行验证来验证用户。
为此，服务器必须为用户提供专门为他生成的证书，为主题分配值，以便这些值可用于确定证书应验证哪个用户。
用户在浏览器上安装证书，将其用于网站。

在以下情况下这样做是个好主意：

- 用户只能从一台计算机/浏览器访问网站是可以接受的（甚至是首选）。
- 在浏览器上安装 TLS 证书的过程不会轻易吓到用户，或者会有人（可能来自 IT 支持人员）为用户执行此操作。
- 该网站需要额外的安全措施。
- 当网站用于公司或组织的内部网时，使用它也是一件好事。

将此方法用于具有普通用户的广泛且公开可用的网站通常不是一个好主意。例如，
为 Facebook 这样的网站实施此功能并不是一个好主意。虽然这种技术可以防止用户输入密码
（从而防止普通键盘记录器窃取密码），但还是认为结合使用密码和 TLS 客户端身份验证是好主意。

此外，如果客户端位于执行 SSL/TLS 解密的企业代理之后，这将破坏证书身份验证，除非代理允许该站点。

有关更多信息，请参阅：[客户端验证 TLS 握手](https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake)

### 身份验证和错误消息

在身份验证功能中错误实现的错误消息可用于用户 ID 和密码枚举。应用程序应该响应通用的错误信息，不论：

- 用户 ID 或密码不正确。
- 该帐户不存在。
- 帐户被锁定或禁用。

帐户注册功能也应该纳入考虑，对于用户存在的情况，可以应用相同的通用错误消息方法。

这样的目的是防止创建[差异因素](https://cwe.mitre.org/data/definitions/204.html)，
允许攻击者针对应用程序安装用户枚举操作。

有趣的是，业务逻辑本身会带来与所用处理时间相关的差异因素。的确，依赖于实现，
处理的时间可能会因为处理结果的不同（成功或失败）而明显不一样（例如几秒的增量），
允许攻击者发起[基于时间的攻击](https://en.wikipedia.org/wiki/Timing_attack)。

使用伪代码登录功能的示例：

- 使用“快速退出”方法的第一个实现

```
IF USER_EXISTS(username) THEN
    password_hash=HASH(password)
    IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
    IF NOT IS_VALID THEN
        RETURN Error("Invalid Username or Password!")
    ENDIF
ELSE
   RETURN Error("Invalid Username or Password!")
ENDIF
```

可以清楚地看到，如果用户不存在，应用程序会直接抛出错误。
否则，当用户存在而密码不存在时，显然在应用程序出错之前会有更多的处理。
返回后，相同错误的响应时间会有所不同，从而允许攻击者区分是用户名错误还是密码错误。

- 不依赖“快速退出”方法的第二个实现：

```
password_hash=HASH(password)
IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
IF NOT IS_VALID THEN
   RETURN Error("Invalid Username or Password!")
ENDIF
```

无论用户或密码是什么，此代码都将经历相同的过程，从而允许应用程序在大约相同的响应时间内返回。

返回通用错误消息的问题是一个用户体验 (UX) 相关的问题。 合法用户可能会对通用消息感到困惑，
从而使他们难以使用该应用程序，并且可能会在多次重试后因应用程序的复杂性而离开该应用程序。
可以根据应用程序及其数据的重要性来决定是否返回*通用的错误消息*。
例如，对于关键应用程序，团队可以决定在失败情况下，用户将始终被重定向到支持页面并返回一般错误消息。

关于用户枚举本身，防止[暴力攻击](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#protect-against-automated-attacks)
也是有效的，因为它们可以防止攻击者大规模应用枚举。
在必须保留用户体验而无法返回一般错误消息的功能时可以使用
[CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA)。

#### 不正确和正确的响应示例

##### 登录

不正确的响应示例：

- “用户 foo 登录：密码无效。”
- “登录失败，用户 ID 无效。”
- “登录失败；帐户已禁用。”
- “登录失败；此用户未激活。”

正确响应示例：

- “登录失败；无效的用户 ID 或密码。”

##### 找回密码

不正确的响应示例：

- “我们刚刚向您发送了一个密码重置链接。”
- “我们的数据库中不存在此电子邮件地址。”

正确响应示例：

- “如果该电子邮件地址在我们的数据库中，我们将向您发送一封电子邮件以重置您的密码。”

##### 帐户创建

不正确的响应示例：

- “此用户 ID 已被使用。”
- “欢迎您！您已注册成功。”

正确响应示例：

- “激活帐户的链接已通过电子邮件发送到提供的地址。”

##### 错误代码和 URL

根据身份验证尝试响应，应用程序可能会返回不同的 HTTP 错误代码。
它可能会以 200 表示正面结果和 403 表示负面结果。
即使向用户显示一般错误页面，HTTP 响应码不同也可能会泄露有关帐户是否有效的信息。

错误披露也可以用作差异因素，有关应用程序中不同错误的全局处理，请参阅[错误处理备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)。

### 防止自动攻击

攻击者可以使用多种不同类型的自动攻击来尝试破坏用户帐户。下面列出了最常见的类型：

| 攻击类型 | 描述                                           |
| -------- | ---------------------------------------------- |
| 暴力破解 | 针对单个帐户测试来自字典或其他来源的多个密码。 |
| 凭证填充 | 测试从另一个站点的入侵中获得的用户名/密码对。  |
| 密码喷洒 | 针对大量不同帐户测试单个弱密码。               |

可以实施不同的保护机制来防止这些攻击。在许多情况下，这些防御措施并不能提供完整的保护，
但是，当其中一些措施以纵深防御方式实施时，就可以实现合理的保护水平。

以下部分将主要侧重于防止暴力攻击，尽管这些控制措施也可以有效抵御其他类型的攻击。
有关防范凭证填充和密码喷洒的进一步指导，请参阅[凭证填充备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html)。

#### 多重身份验证

到目前为止，多因素身份验证 (MFA) 是抵御大多数与密码相关的攻击（包括蛮力攻击）的最佳防御措施，
微软的分析表明，它可以阻止 [99.9% 的帐户泄露](https://techcommunity.microsoft.com/t5/Azure-Active-Directory-Identity/Your-Pa-word-doesn-t-matter/ba-p/731984)。
因此，应尽可能实施；但是，根据应用程序的受众，强制使用 MFA 可能不切实际或不可行。

[多因素身份验证备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html) 包含有关实施 MFA 的进一步指导。

#### 帐户锁定

针对这些攻击的最常见保护措施是实施帐户锁定，以防止在一定数量的登录失败后的一段时间内再次尝试登录。
登录失败的计数器应该与帐户本身相关联，而不是与源 IP 地址相关联，以防止攻击者从大量不同的 IP
地址进行登录尝试。
在实施帐户锁定策略以在安全性和可用性之间找到平衡时，应考虑许多不同的因素：

- 帐户被锁定之前的失败尝试次数（锁定阈值）。
- 这些尝试必须在时间段内发生（观察窗口）。
- 帐户被锁定的时间（锁定持续时间）。

一些应用程序没有实施固定的锁定持续时间（例如，十分钟），而是使用指数锁定，
锁定持续时间从很短的时间开始（例如，一秒），但在每次登录尝试失败后加倍。

在设计帐户锁定系统时，必须注意防止它被用来通过锁定其他用户的帐户来导致拒绝服务。
可以执行的一种方法是允许忘记密码功能的用户登录，即使帐户被锁定。

#### CAPTCHA

使用有效的 CAPTCHA 可以帮助防止针对帐户的自动登录尝试。
然而，许多 CAPTCHA 实现存在弱点，允许使用自动化技术解决它们，或者可以外包给可以解决它们的服务。
因此，CAPTCHA 的使用应被视为一种深度防御控制，以使暴力攻击更加耗时和昂贵，而不是一种预防措施。

仅在少量失败的登录尝试后才要求解决 CAPTCHA 可能更加用户友好，而不是从第一次登录时就要求它。

#### 安全问题和难忘的词

添加安全问题或令人难忘的单词也有助于防止自动攻击，尤其是当用户被要求从单词中输入一些随机选择的字符时。
应该注意的是，这并**不**构成多因素身份验证，因为这两个因素是相同的（您知道的）。
此外，安全问题通常很弱并且有可预测的答案，因此必须谨慎选择。
[选择和使用安全问题备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)包含这方面的进一步指导。

## 日志记录和监控

启用身份验证功能的日志记录和监控，以实时检测攻击/故障

- 确保记录和审查所有故障
- 确保所有密码失败都被记录和审查
- 确保记录和审查所有帐户锁定

## 使用不需要密码的认证协议

虽然通过用户/密码组合进行身份验证和使用多因素身份验证通常被认为是安全的，但在某些用例中，
它不被认为是最佳选择甚至不安全。
这方面的示例是希望从移动设备、另一个网站、桌面或其他情况连接到 Web 应用程序的第三方应用程序。
发生这种情况时，允许第三方应用程序存储用户/密码组合被认为是不安全的，因为它会将攻击面扩展到他们的手中，
而不受您的控制。
对于此用例和其他用例，有多种身份验证协议可以保护您免于将用户数据暴露给攻击者。

### OAuth

开放授权 (OAuth) 是一种协议，允许应用程序以用户身份对服务器进行身份验证，
而无需密码或充当身份提供者的任何第三方服务器。
它使用由服务器生成的令牌并提供授权流最常发生的方式，以便客户端（例如移动应用程序）
可以告诉服务器哪些用户正在使用该服务。

建议使用和实施 OAuth 1.0a 或 OAuth 2.0，因为已经发现第一个版本 (OAuth1.0)
容易受到会话固定的影响。

OAuth 2.0 依赖 HTTPS 来确保安全性，目前由 Facebook、Google、Twitter 和 Microsoft
等公司的 API 使用和实现。
OAuth1.0a 更难使用，因为它需要使用加密库进行数字签名。
但是，由于 OAuth1.0a 不依赖 HTTPS 来确保安全性，因此它更适合于风险较高的交易。

### OpenId

OpenId 是一种基于 HTTP 的协议，它使用身份提供程序来验证用户的身份。
这是一个非常简单的协议，允许服务提供商发起单点登录 (SSO)。
这允许用户重复使用提供给受信任 OpenId 身份提供者的单个身份，并在多个网站中成为同一用户，
而无需向任何网站提供密码，OpenId 身份提供者除外。

由于其简单性并提供密码保护，OpenId 已被广泛采用。
一些著名的 OpenId 身份提供商是 Stack Exchange、Google、Facebook 和 Yahoo!

对于非企业环境，只要身份提供者值得信任，OpenId 就被认为是一种安全且通常更好的选择。

### SAML

安全断言标记语言 (SAML) 通常被认为与 OpenId 竞争。
最推荐的版本是 2.0，因为它的功能非常完整并且提供了强大的安全性。
与 OpenId 一样，SAML 使用身份提供者，但与 OpenId 不同的是，它基于 XML 并提供更大的灵活性。
SAML 基于发送 XML 数据的浏览器重定向。
此外，SAML 不仅由服务提供商发起；它也可以从身份提供者发起。
这允许用户在无需执行任何操作的情况下仍然通过不同的门户浏览不同的门户，从而使过程透明。

虽然 OpenId 占据了大部分消费市场，SAML 通常是企业应用程序的选择。
这样做的原因通常是很少有 OpenId 身份提供者被认为是企业级的
（意味着他们验证用户身份的方式没有企业身份所需的高标准）。
在 Intranet 网站内部使用 SAML 更为常见，有时甚至使用 Intranet 中的服务器作为身份提供者。

在过去的几年里，当 Web 服务和 Web 应用程序需要企业联盟时，SAP ERP 和 SharePoint 等应用程序
（SharePoint 使用 Active Directory 联合身份验证服务 2.0）
决定使用 SAML 2.0 身份验证作为单点登录实施的常用方法。

另请参阅：[SAML 安全备忘录](https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html)

### FIDO

快速身份在线 (FIDO) 联盟创建了两个协议来促进在线身份验证：
通用认证框架 (UAF) 协议和通用第二因素 (U2F) 协议。
其中 UAF 专注于无密码身份验证，但 U2F 允许在现有的基于密码的身份验证中添加第二个因素。
这两种协议都基于公钥加密挑战-响应模型。

UAF 利用设备上现有的安全技术进行身份验证，包括指纹传感器、相机（面部生物识别）、
麦克风（语音生物识别）、可信执行环境（TEE）、安全元件（SE）等。
该协议旨在将这些设备功能插入到一个通用的身份验证框架中。 UAF 适用于本机应用程序和 Web 应用程序。

U2F 使用存储加密身份验证密钥并使用它们进行签名的硬件令牌（通常是 USB）来增强基于密码的身份验证。
用户可以使用相同的令牌作为多个应用程序的第二个因素。
U2F 适用于 Web 应用程序。它通过使用网站的 URL 查找存储的身份验证密钥来**防止网络钓鱼**。

## 密码管理器

密码管理器是自动管理大量不同凭据的程序、浏览器插件或 Web 服务。
大多数密码管理器都具有允许用户在网站上轻松使用它们的功能，方法是将密码粘贴到登录表单中，
或者模拟用户输入密码。

通过遵守以下建议，Web 应用程序至少不应使密码管理器的工作变得过于困难：

- 使用具有适当`type`属性的用户名和密码输入标准 HTML 表单。
  - 避免基于插件的登录页面（例如 Flash 或 Silverlight）。
- 实施合理的最大密码长度，例如 64 个字符，如密码存储备忘录中所述。
- 允许在密码中使用任何可打印的字符。
- 允许用户粘贴到用户名和密码字段中。
- 允许用户通过按一次 `Tab` 键在用户名和密码字段之间导航。
